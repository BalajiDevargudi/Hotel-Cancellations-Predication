# -*- coding: utf-8 -*-
"""hotel-cancelprediction (1).ipynb

Automatically generated by Colaboratory.

Original file is located at
    https://colab.research.google.com/drive/1r0sTqh0tO5ST2oU-2voIccSE1bLQLpJ_
"""

import matplotlib.pyplot as plt
import seaborn as sns
import pandas as pd
import numpy as np

from sklearn.preprocessing import LabelEncoder, StandardScaler, MinMaxScaler
from sklearn.model_selection import train_test_split, cross_val_score, GridSearchCV
from sklearn.feature_selection import SelectFromModel, SelectPercentile
from sklearn.metrics import f1_score, confusion_matrix

from sklearn.linear_model import LogisticRegression, RidgeClassifier, SGDClassifier
from sklearn.svm import LinearSVC
from sklearn.tree import DecisionTreeClassifier
from sklearn.ensemble import RandomForestClassifier, GradientBoostingClassifier, AdaBoostClassifier
from sklearn.neighbors import KNeighborsClassifier
from sklearn.neural_network import MLPClassifier
from sklearn.naive_bayes import GaussianNB

pd.set_option('display.max_columns', None)

from google.colab import drive
drive.mount('/content/drive')

df = pd.read_csv("/content/drive/MyDrive/Dataset/hotel_bookings.csv")

df.head()

df.shape

df.describe()

df.info()

df.isnull().sum()

df.fillna(0,inplace=True)

category_people  = ["adults","children","babies"]
for i in category_people:
    print("Count of: ",i)
    print(df[i].value_counts())
    print()

filtered = (df["adults"]==0) & (df["children"]==0) & (df["babies"]==0)
fl_data  = df[~(filtered)]

filtered.sum()

fl_data.shape

country_data = df[df["is_canceled"]==0]["country"].value_counts().reset_index()

country_data.head(15)

import plotly.express as px

geo = px.choropleth(country_data,locations=country_data["index"],color = country_data["country"],hover_name=country_data["index"], title="Geospatial hotel data")

geo.show()

#types of hotel and most choosed
df["hotel"].value_counts()

fl_data

data = fl_data[fl_data["is_canceled"] == 0]

data

plt.figure(figsize=(12,8))
sns.boxplot(x = "reserved_room_type",
           y = "adr", 
           hue = "hotel", data = data)
plt.title("Price of room types per night per person", fontsize = 16)
plt.xlabel("Room type")
plt.ylabel("Price [EUR]")
plt.legend(loc = "upper right")
plt.ylim(0,600)
plt.show()

resort_data = fl_data[(fl_data["hotel"]=="Resort Hotel")&(fl_data["is_canceled"] == 0)]

resort_pay_month =resort_data.groupby(["arrival_date_month"])["adr"].mean().reset_index()

city_data = fl_data[(fl_data["hotel"]=="City Hotel")& (fl_data["is_canceled"]==0)]

city_data.reset_index()

city_pay_month = city_data.groupby(["arrival_date_month"])["adr"].mean().reset_index()

f = resort_pay_month.merge(city_pay_month,on="arrival_date_month")

f

from calendar import month_name

def sort_month(df, colname):
    month_dict = { j:i for i, j in enumerate(month_name) } #dictionary comprehension
    df["month_num"] = df[colname].apply(lambda x: month_dict[x])
    return df.sort_values(by = "month_num").reset_index().drop(['index', 'month_num'], axis = 1)

ff = sort_month(f,"arrival_date_month")

ff
ff.columns = ["month","Resort","City"]

ff.plot(kind = "bar", x = "month", y = ['Resort','City'])

rush_resort = resort_data["arrival_date_month"].value_counts().reset_index()
rush_resort.columns = ["month", "no of guests"]

print(rush_resort)

rush_city = city_data["arrival_date_month"].value_counts().reset_index()
rush_city.columns = ["month","no of guests"]
print(rush_city)

final_rush = rush_resort.merge(rush_city,on="month")

final_rush

final_rust_filter = sort_month(final_rush,"month")

final_rust_filter

final_rust_filter.plot(kind="bar",x="month",y=["no of guests_x","no of guests_y"])

clean_data=fl_data[fl_data["is_canceled"]==0]
clean_data.head()

clean_data["total_nights"]=clean_data["stays_in_weekend_nights"]+clean_data["stays_in_week_nights"]

clean_data["total_nights"]

sty =clean_data.groupby(["total_nights","hotel"]).agg("count").reset_index()

clean_data.columns

sty=sty.iloc[:,0:3]

sty = sty.rename(columns={'is_canceled':'Number of stays'})

sty

sns.barplot(x = "total_nights", y = "Number of stays", hue = "hotel",hue_order = ["City Hotel", "Resort Hotel"], data = sty)

fl_data

corre = fl_data.corr()

corre

sns.heatmap(data =corre,annot=True)

corre["is_canceled"][1:]

['meal', 'assigned_room_type', 'reserved_room_type', 'reservation_status', 'reservation_status_date', 'arrival_date']

month_map = {'January':'01', 'February':'02', 'March':'03', 'April':'04', 'May':'05', 'June':'06', 'July':'07', 'August':'08', 'September':'09', 'October':'10', 'November':'11', 'December':'12'}
df.arrival_date_month = fl_data.arrival_date_month.map(month_map).astype(int)

df

df['arrival_date'] = df['arrival_date_year'].astype(str)+'-'+df['arrival_date_month'].astype(str)+'-'+df['arrival_date_day_of_month'].astype(str)

df

def roomChange(row):
    if row['assigned_room_type'] == row['reserved_room_type']:
        return 0
    else:
        return 1

df['change_in_room'] = df.apply(roomChange, axis=1)

df

df.columns

df['offspring'] = (df['children'] + df['babies']).astype(int)

df

df['total_bookings'] = df['previous_cancellations'] + df['previous_bookings_not_canceled']

# (df["country"]==0).sum()

type(df['country'].mode())

df["country"]=df["country"].replace(0,df['country'].mode()[0])
df["agent"]=df["agent"].replace(0,df['agent'].mode()[0])
df["company"]=df["company"].replace(0,df['company'].mode()[0])

for i in range(len(df)):
    if df.loc[i, 'country'] == 'PRT':
        df.at[i, 'country'] = 1
    elif df.loc[i, 'country'] == 'GBR':
        df.at[i, 'country'] = 2
    else:
        df.at[i, 'country'] = 0

# df['stay_duration'] = df['reservation_status_date'] - df['arrival_date']
# df['stay_duration'] = df['stay_duration'] / np.timedelta64(1, 'D')
# df['stay_duration'] = df['stay_duration'].astype(int)

list_not = ["days_in_waiting_list", "arrival_date_year"]

num_features = [col for col in df.columns if df[col].dtype != "O" and col not in list_not]  #numerical one

df["reservation_status"].value_counts()

df.columns

cat_not = ["country", "reservation_status", "booking_changes", "assigned_room_type", "days_in_waiting_list" ]

cat_features = [col for col in df.columns 
                if df[col].dtype == "O" and col not in cat_not]

print(cat_features)

print(num_features)

data_cat = df[cat_features]

import warnings
from warnings import filterwarnings
filterwarnings("ignore")

data_cat["reservation_status_date"] = pd.to_datetime(data_cat["reservation_status_date"])

data_cat["year"] = data_cat["reservation_status_date"].dt.year

data_cat["month"] = data_cat["reservation_status_date"].dt.month

data_cat["day"] = data_cat["reservation_status_date"].dt.day

data_cat.drop("reservation_status_date", axis = 1, inplace = True)

data_cat.columns

data_cat["cancellation"] = df["is_canceled"]

def mean_encode(df, col, mean_col):
    df_dict = df.groupby([col])[mean_col].mean().to_dict()
    df[col] = df[col].map(df_dict)
    print(df_dict)
    return df

for col in data_cat.columns[0:8]:
    data_cat = mean_encode(data_cat, col, "cancellation")

data_cat.drop(["cancellation"], axis = 1, inplace = True)

print(data_cat)

num_data = df[num_features] #numerical data

cat_data = data_cat #categorical data


dataframe = pd.concat([num_data, cat_data], axis = 1) #final dataframe

num_features

df.columns

dataframe.describe()["adr"]

sns.distplot(dataframe["lead_time"])

def handle_outlier(col):
    dataframe[col] = np.log1p(dataframe[col])

handle_outlier("lead_time")

sns.distplot(dataframe["lead_time"].dropna())

sns.distplot(dataframe["adr"])

handle_outlier("adr")

dataframe.isnull().sum()

dataframe=dataframe.dropna()



x_train.drop(['lead_time','arrival_date_month','arrival_date_week_number'], axis = 1, inplace = True)

x_train.drop(['arrival_date_day_of_month','stays_in_weekend_nights','stays_in_week_nights'], axis = 1, inplace = True)

x_train.drop(['children','babies','arrival_date'], axis = 1, inplace = True)

x_train.drop(['year', 'month', 'day'], axis = 1, inplace = True)

##separate dependent and independent variables

y = dataframe["is_canceled"] #dependent variable

X = dataframe.drop("is_canceled", axis = 1) #independent

X.columns

from sklearn.linear_model import Lasso
from sklearn.feature_selection import SelectFromModel

feature_sel_model = SelectFromModel(Lasso(alpha = 0.005, random_state = 0))

feature_sel_model.fit(X, y)

feature_sel_model.get_support()

from sklearn.model_selection import train_test_split

x_train, x_test, y_train, y_test = train_test_split(X, y, train_size = 0.75, random_state = 45)

from sklearn.linear_model import LogisticRegression

logistic_model = LogisticRegression()
logistic_model.fit(x_train, y_train) #training of the model

y_pred = logistic_model.predict(x_test) #prediction by model

from sklearn.metrics import confusion_matrix

x_train.columns

x_train

y_train

confusion_matrix(y_test, y_pred)

from sklearn.metrics import accuracy_score

accuracy_score(y_test, y_pred)

from sklearn.naive_bayes import GaussianNB
from sklearn.neighbors import KNeighborsClassifier
from sklearn.ensemble import RandomForestClassifier
from sklearn.tree import DecisionTreeClassifier

models = []

models.append(("Naive Bayes", GaussianNB()))
models.append(("Random Forest", RandomForestClassifier()))
models.append(("Decision Tree", DecisionTreeClassifier()))
models.append(("KNN", KNeighborsClassifier(n_neighbors = 5)))

for name, model in models:
    print(name)
    model.fit(x_train, y_train)
    
    #make a predictions
    predictions = model.predict(x_test)
    
    #evaluate a model
    from sklearn.metrics import confusion_matrix
    print(confusion_matrix(predictions, y_test))
    
    from sklearn.metrics import accuracy_score
    print(accuracy_score(predictions, y_test))
    
    print("\n")

